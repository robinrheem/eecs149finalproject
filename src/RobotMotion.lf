target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    single-threaded: true
  }
  
import Display from "lib/Display.lf"
import Encoders from "lib/Encoders.lf"
import Motors from "lib/Motors.lf"
import Accelerometer from "lib/IMU.lf"
import GyroAngle from "lib/IMU.lf"

preamble {=
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "pico/stdlib.h"
=}

main reactor {
    e = new Encoders()
    m = new Motors()
    a = new Accelerometer()
    g = new GyroAngle()
    d = new Display()

    timer t(0, 10ms)

    // ------------------------------------------------------------
    // Command parsing
    // ------------------------------------------------------------
    state buf: char*
    state buf_size: int = 17
    state idx: int = 0

    // Motor power commands [-1.0, 1.0]
    state left_power: float = 0.0
    state right_power: float = 0.0

    // ------------------------------------------------------------
    // Driving (encoder-based distance)
    // ------------------------------------------------------------
    state start_ticks: float = 0.0
    state target_ticks: float = 0.0
    state driving_initialized: int = 0

    // ------------------------------------------------------------
    // Turning (gyro yaw)
    // ------------------------------------------------------------
    state current_yaw: float = 0.0
    state start_angle: float = 0.0
    state target_angle_delta: float = 0.0   // +left, âˆ’right

    // ------------------------------------------------------------
    // Periodic sensor updates
    // ------------------------------------------------------------
    reaction(t) -> e.trigger, a.trigger, g.trigger {=
        lf_set(e.trigger, true);
        lf_set(a.trigger, true);
        lf_set(g.trigger, true);
    =}

    // ------------------------------------------------------------
    // Startup
    // ------------------------------------------------------------
    reaction(startup) -> m.left_power, m.right_power, d.line0 {=
        stdio_init_all();

        self->buf = (char*) malloc(self->buf_size);
        if (self->buf != NULL) {
            self->buf[0] = '\0';
        }

        lf_set(m.left_power, 0.0f);
        lf_set(m.right_power, 0.0f);
        lf_set(d.line0, "Mode: CMD");
    =}

    // ------------------------------------------------------------
    // Keep track of yaw
    // ------------------------------------------------------------
    reaction(g.z) {=
        self->current_yaw = g.z->value;
    =}

    reaction(g.z) -> d.line1 {=
        static char buf[17];
        snprintf(buf, 17, "yaw: %.1f", g.z->value);
        lf_set(d.line1, buf);
    =}

    // ============================================================
    // MODE 1: COMMAND_PARSING
    // ============================================================
    initial mode COMMAND_PARSING {
        reaction(t) -> reset(DRIVING), reset(TURNING), reset(GOAL), reset(STOP), d.line0, d.line2 {=

            if (self->buf == NULL) return;

            int c;
            while ((c = getchar_timeout_us(0)) != PICO_ERROR_TIMEOUT) {
                if (c == '\n' || c == '\r') {
                    self->buf[self->idx] = '\0';

                    if (self->idx > 0) {
                        lf_set(d.line2, self->buf);
                    }
                    self->idx = 0;

                    if (strcmp(self->buf, "drive") == 0) {
                        lf_set(d.line0, "Command: DRIVE");

                        self->left_power  = 0.3f;
                        self->right_power = 0.3f;

                        self->target_ticks = 1000.0f;
                        self->driving_initialized = 0;

                        lf_set_mode(DRIVING);
                        return;

                    } else if (strcmp(self->buf, "turn_left") == 0) {
                        lf_set(d.line0, "Command: TURN L");

                        self->left_power  = -0.3f;
                        self->right_power =  0.3f;

                        self->start_angle = self->current_yaw;
                        self->target_angle_delta = 5.0f;

                        lf_set_mode(TURNING);
                        return;

                    } else if (strcmp(self->buf, "turn_right") == 0) {
                        lf_set(d.line0, "Command: TURN R");

                        self->left_power  =  0.3f;
                        self->right_power = -0.3f;

                        self->start_angle = self->current_yaw;
                        self->target_angle_delta = -5.0f;

                        lf_set_mode(TURNING);
                        return;

                    } else if (strcmp(self->buf, "goal") == 0) {
                        lf_set(d.line0, "Command: GOAL");

                        self->left_power  = 0.3f;
                        self->right_power = 0.3f;
                        self->driving_initialized = 0;

                        lf_set_mode(GOAL);
                        return;

                    } else if (strcmp(self->buf, "stop") == 0) {
                        lf_set(d.line0, "Command: STOP");

                        self->left_power  = 0.0f;
                        self->right_power = 0.0f;

                        lf_set_mode(STOP);
                        return;

                    } else if (self->buf[0] != '\0') {
                        lf_set(d.line0, "Unknown Command");
                    }

                    self->buf[0] = '\0';

                } else if (self->idx < self->buf_size - 1) {
                    self->buf[self->idx++] = (char)c;
                }
            }
        =}
    }

    // ============================================================
    // MODE 2: DRIVING
    // ============================================================
    mode DRIVING {
        reaction(t, e.left, e.right) -> reset(COMMAND_PARSING), m.left_power, m.right_power, d.line0 {=

            if (!self->driving_initialized) {
                float avg = (fabs(e.left->value) + fabs(e.right->value)) / 2.0f;
                self->start_ticks = avg;
                self->driving_initialized = 1;
            }

            lf_set(m.left_power, self->left_power);
            lf_set(m.right_power, self->right_power);

            float avg = (fabs(e.left->value) + fabs(e.right->value)) / 2.0f;
            float traveled = avg - self->start_ticks;

            if (traveled >= self->target_ticks) {
                lf_set(m.left_power, 0.0f);
                lf_set(m.right_power, 0.0f);
                lf_set(d.line0, "Drive done");
                lf_set_mode(COMMAND_PARSING);
            }
        =}
    }

    // ============================================================
    // MODE 3: TURNING
    // ============================================================
    mode TURNING {
        reaction(t) -> reset(COMMAND_PARSING), m.left_power, m.right_power, d.line0 {=

            lf_set(m.left_power, self->left_power);
            lf_set(m.right_power, self->right_power);

            float delta = self->current_yaw - self->start_angle;

            if ((self->target_angle_delta > 0 && delta >= self->target_angle_delta) ||
                (self->target_angle_delta < 0 && delta <= self->target_angle_delta)) {

                lf_set(m.left_power, 0.0f);
                lf_set(m.right_power, 0.0f);
                lf_set(d.line0, "Turn done");
                lf_set_mode(COMMAND_PARSING);
            }
        =}
    }

    // ============================================================
    // MODE 4: STOP
    // ============================================================
    mode STOP {
        reaction(t) -> reset(COMMAND_PARSING), m.left_power, m.right_power, d.line0 {=

            lf_set(m.left_power, 0.0f);
            lf_set(m.right_power, 0.0f);
            lf_set(d.line0, "Stopped");
            lf_set_mode(COMMAND_PARSING);
        =}
    }

    // ============================================================
    // MODE 5: GOAL
    // ============================================================
    mode GOAL {
        reaction(t, e.left, e.right) -> reset(COMMAND_PARSING), m.left_power, m.right_power, d.line0 {=

            if (!self->driving_initialized) {
                float avg = (fabs(e.left->value) + fabs(e.right->value)) / 2.0f;
                self->start_ticks = avg;
                self->driving_initialized = 1;
            }

            lf_set(m.left_power, self->left_power);
            lf_set(m.right_power, self->right_power);

            float avg = (fabs(e.left->value) + fabs(e.right->value)) / 2.0f;
            float traveled = avg - self->start_ticks;

            if (traveled >= 10000.0f) {
                lf_set(m.left_power, 0.0f);
                lf_set(m.right_power, 0.0f);
                lf_set(d.line0, "Goal hit");
                lf_set_mode(COMMAND_PARSING);
            }
        =}
    }
}
