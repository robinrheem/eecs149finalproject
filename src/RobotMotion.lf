/**
  * Robot Motion Main Robot Control
  */

target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  single-threaded: true
}

import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import GyroAngle from "lib/IMU.lf"
import Encoders from "lib/Encoders.lf"
// import EdgeSensor from "EdgeSensor.lf"

preamble {=
  #include <math.h>
=}

// returns distance travelled in meters.
reactor AngleToDistance {
  input angle: int32_t
  output distance: float

  reaction(angle) -> distance {=
      // arc length = theta * r, where theta is in radians
      lf_set(distance, (float) angle->value * ((float) M_PI / 180.0f) * (0.03175f / 2.0f));
  =}
}

reactor RandomFloat {
  output random_float: float

  reaction(startup) -> random_float {=
    srand(time(0));
    return ((float) rand() / (float) RAND_MAX);
  =}
}

reactor Robot {
  reset state temp_dist: float = 0
  input l_dist: float
  input r_dist: float

  reset state temp_angle: float = 0
  input yaw: float     // Yaw angle

  reset state l_speed: float = 0.1
  reset state r_speed: float = 0.1

  // outputs for motor
  output left: float
  output right: float

  output l0: string
  output l1: string
  output l2: string
  output l3: string

  // state goal_found: bool = false

  initial mode DRIVING {
    reaction (yaw) -> l0, l2, l3, left, right {=
      lf_set(l0, "DRIVING");

      // float speed_adjustment = fabs(y * 0.02);
      if (yaw->value < -2.0f) {
        // self->l_speed += speed_adjustment;
        // self->r_speed -= speed_adjustment;        
        
        static char buf[17];
        snprintf(buf, 17, "ls: %.4f", yaw->value);
        lf_set(l2, buf);

        lf_set(left, 0.1f);
        lf_set(right, 0.07f);

        lf_set(l3, "adjust left");
      } else if (yaw->value > 2.0f) {
        // self->l_speed -= speed_adjustment;
        // self->r_speed += speed_adjustment;

        static char buf[17];
        snprintf(buf, 17, "ls: %.4f", yaw->value);
        lf_set(l2, buf);

        lf_set(left, 0.07f);
        lf_set(right, 0.1f);
        lf_set(l3, "adjust right");
      } else {
        lf_set(left, 0.1f);
        lf_set(right, 0.1f);

        static char buf[17];
        snprintf(buf, 17, "ls: %.4f", yaw->value);
        lf_set(l2, buf);

        lf_set(l3, "ok");
      }
    =}

    reaction(l_dist, r_dist) yaw -> reset(TURNING), l0, left, right {=
      lf_set(l0, "DRIVING");

      float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;

      if (fabs(self->temp_dist - lr_avg_dist) >= 0.5f) {
        lf_set(l0, "stop");
        lf_set(left, 0.0f);
        lf_set(right, 0.0f);

        self->temp_angle = yaw->value;

        lf_set_mode(TURNING);
      }
    =}
  }

  mode TURNING {
    reaction(yaw) l_dist, r_dist -> reset(DRIVING), l0, left, right {=
      lf_set(l0, "TURNING");

      lf_set(left, 0.0f);
      lf_set(right, self->r_speed);

      if (fabs(self->temp_angle - yaw->value) >= 90) {
        lf_set(l0, "stop turning");

        lf_set(left, 0.0f);
        lf_set(right, 0.0f);

        float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;
        self->temp_dist = lr_avg_dist;
        self->temp_angle = yaw->value;

        lf_set_mode(DRIVING);

      }
    =}
  }

  // initial mode OBSERVING {
  //   // is the goal target in my vision?
  //   reaction(startup) {=
  //     // send camera data to VLM
  //     // get output and set goal_found to status
  //   =}

  //   // if yes, change mode to pathfind, else search
  //   reaction (goal_found) -> reset(SEARCH), reset(PATHFIND) {=
  //     if (goal_found) {
  //       lf_set_mode(PATHFIND);
  //     } else {
  //       lf_set_mode(SEARCH);
  //     }
  //   =}
  // }

  // mode SEARCH {
  //   // different naive implementations
  //   // 1. random walk
  //   // 2. spiral

  //   // lets assume random walk for now
  //   // start in scan mode, ask VLM if target is in view: if yes, switch to pathfind
  //   // else: turn a random angle,
  //   // then move forward a random angle
  //   // if obstacle (object that is not target) in view, back up and turn? or maybe use bump sensor?
  //   // after, go back to OBSERVING
  //   reaction (startup) -> reset(TURN_RANDOM) {=
  //     lf_set_mode(TURN_RANDOM);
  //   =}
  // }

  // mode TURN_RANDOM {
  //   reaction(yaw) l_dist, r_dist -> reset(MOVE_FORWARD_RANDOM), motor.left_power, motor.right_power {=
  //     lf_set(motor.left_power, -0.05f);
  //     lf_set(motor.right_power, 0.05f);

  //     float random_angle = 25 // TODO: replace placeholder

  //     if (fabs(self->temp_angle - yaw->value) >= random_angle) {
  //       lf_set(motor.left_power, 0.0f);
  //       lf_set(motor.right_power, 0.0f);

  //       // TODO: maybe check if there is an object in front?
  //       // if yes then keep rotating ? or until it leaves the camera periphery?

  //       float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;
  //       self->temp_dist = lr_avg_dist;

  //       lf_set_mode(MOVE_FORWARD_RANDOM);
  //     }
  //   =}
  // }

  // mode MOVE_FORWARD_RANDOM {
  //   reaction(l_dist, r_dist) yaw -> reset(OBSERVING), motor.left_power, motor.right_power {=
  //     lf_set(motor.left_power, 0.1f);
  //     lf_set(motor.right_power, 0.1f);

  //     float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;

  //     float random_dist = 0.5f;

  //     if (fabs(self->temp_dist - lr_avg_dist) >= random_dist) {
  //       lf_set(motor.left_power, 0.0f);
  //       lf_set(motor.right_power, 0.0f);

  //       self->temp_angle = yaw->value;

  //       lf_set_mode(OBSERVING);
  //     }
  //   =}
  // }

  // mode PATHFIND {
  //   // target object has been found, start travelling toward it
  //   // keep object in center as much as possible
  //   // if target is behind an object, try to navigate around it
  //   // maybe keep some bias direction so the robot knows to eventually travel to it after avoiding

  //   // should camera observation, VLM request and navigation be in parallel?
  // }
}
  
main reactor {
  timer t(0, 20 msec) // need this to be kind of frequent to avoid delay in 

  robot = new Robot()
  motor = new MotorsWithFeedback()
  d = new Display()

  // gets distance traveled
  encoder = new Encoders()
  c1 = new AngleToDistance()
  c2 = new AngleToDistance()

  // gets yaw measurement
  gyro = new GyroAngle()

  encoder.left -> c1.angle
  encoder.right -> c2.angle
  c1.distance -> robot.l_dist
  c2.distance -> robot.r_dist

  gyro.z -> robot.yaw

  robot.l0 -> d.line0
  robot.l1 -> d.line1
  robot.l2 -> d.line2
  robot.l3 -> d.line3

  reaction(t) -> encoder.trigger, gyro.trigger {=
    lf_set(encoder.trigger, true);
    lf_set(gyro.trigger, true);
  =}
}
