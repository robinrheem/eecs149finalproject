/**
  * Robot Motion Main Robot Control
  */

target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  single-threaded: true
}

import Display from "lib/Display.lf"
// import Motors from "lib/Motors.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import GyroAngle from "lib/IMU.lf"
import Encoders from "lib/Encoders.lf"

preamble {=
  #include <math.h>
  #include "pico/stdlib.h"
=}

// returns distance travelled in meters.
reactor AngleToDistance {
  input angle: int32_t
  output distance: float

  reaction(angle) -> distance {=
      // arc length = theta * r, where theta is in radians
      lf_set(distance, (float) angle->value * ((float) M_PI / 180.0f) * (0.03175f / 2.0f));
  =}
}

reactor Robot {
  reset state temp_dist: float = 0
  input l_dist: float
  input r_dist: float

  reset state temp_angle: float = 0
  input yaw: float     // Yaw angle

  // outputs for motor
  output left: float
  output right: float

  output l0: string
  output l1: string
  output l2: string
  output l3: string

  timer t1(0, 20 ms)

  state buf: char[17] = {0}
  state idx: int = 0
  state r_speed: float = 0.0 //right motor speed 
  state l_speed: float = 0.0 //left motor speed
  state target_dist: float = 0.0 //target distance we want to go
  state target_angle: float = 30.0 //target angle to turn

  initial mode COMMAND_PARSING {
    reaction(t1, yaw) -> reset(DRIVING), reset(TURNING), l0, l2, l3 {=

      int c;
      while ((c = getchar_timeout_us(0)) != PICO_ERROR_TIMEOUT) {
        if (c == '\n' || c == '\r') {
          self->buf[self->idx] = '\0';
          lf_set(l3, self->buf);
          self->idx = 0;

          if (strcmp(self->buf, "drive") == 0) {
              lf_set(l0, "Command: DRIVE");
              self->l_speed = 0.1f;
              self->r_speed = 0.1f;
              self->temp_dist = 0.0f; // Reset initial distance
              lf_set_mode(DRIVING);
          } else if (strcmp(self->buf, "turn left") == 0) {
              lf_set(l0, "Command: TURN LEFT");
              self->l_speed = -0.1f; // Counter-clockwise turn
              self->r_speed = 0.1f;
              self->temp_angle = yaw->value; // Store current yaw
              lf_set_mode(TURNING);
          } else if (strcmp(self->buf, "turn right") == 0) {
              lf_set(l0, "Command: TURN RIGHT");
              self->l_speed = 0.1f; // Clockwise turn
              self->r_speed = -0.1f;
              self->temp_angle = yaw->value; // Store current yaw
              lf_set_mode(TURNING);
          } else {
            lf_set(l0, "receiving data");
          }

        } else if (self->idx < 17 - 1) {
          self->buf[self->idx++] = (char)c;
        }

        lf_set(l0, "Unknown Command");
      }
    =}
  }

  mode DRIVING {
    reaction(l_dist, r_dist) -> reset(COMMAND_PARSING), l0, left, right {=
      lf_set(l0, "DRIVING");

      // Set motor speeds based on state
      lf_set(left, self->l_speed);
      lf_set(right, self->r_speed);

      // Average distance traveled since the mode began 
      float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;
      float traveled_dist = lr_avg_dist - self->temp_dist;

      // Check for distance goal 
      if (traveled_dist >= 0.5f) {
          lf_set(l0, "STOP: Distance reached");
          lf_set(left, 0.0f);
          lf_set(right, 0.0f);
          self->temp_dist = lr_avg_dist; // Update initial distance for next command
          lf_set_mode(COMMAND_PARSING); // Return to wait for next command
      }
    =}
  }

  mode TURNING {
    reaction(yaw) -> reset(COMMAND_PARSING), l0, left, right {=
      lf_set(l0, "TURNING");
      
      // Set motor speeds based on state (set in COMMAND_PARSING)
      lf_set(left, self->l_speed);
      lf_set(right, self->r_speed);

      // Calculate the absolute change in angle
      float angle_change = fabs(self->temp_angle - yaw->value);

      // Check for angle goal (e.g., turn 90 degrees)
      if (angle_change >= self->target_angle) {
          lf_set(l0, "STOP: Angle reached");
          lf_set(left, 0.0f);
          lf_set(right, 0.0f);
          lf_set_mode(COMMAND_PARSING); // Return to wait for next command
      }
    =}
  }

  //   reaction(l_dist, r_dist) yaw -> reset(TURNING), l0, l2, l3, left, right {=
  //     lf_set(l0, "receive data");

  //   //   lf_set(left, 0.1f);
  //   //   lf_set(right, 0.1f);

  //   //   float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;

  //   //   if (fabs(self->temp_dist - lr_avg_dist) >= 2.0f) {
  //   //     lf_set(l0, "stop");
  //   //     lf_set(left, 0.0f);
  //   //     lf_set(right, 0.0f);

  //   //     self->temp_angle = yaw->value;

  //   //     lf_set_mode(TURNING);
  //   //   }
  //   =}
  // }

  // mode TURNING {
  //   reaction(yaw) l_dist, r_dist -> reset(REASONING), l0, left, right {=
  //     lf_set(l0, "TURNING");

  //     lf_set(left, 0.0f);
  //     lf_set(right, self->r_speed);

  //     if (fabs(self->temp_angle - yaw->value) >= 90) {
  //       lf_set(l0, "stop turning");

  //       lf_set(left, 0.0f);
  //       lf_set(right, 0.0f);

  //       float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;
  //       self->temp_dist = lr_avg_dist;
  //       self->temp_angle = yaw->value;

  //       lf_set_mode(DRIVING);

  //     }
  //   =}
  // }
}
  
main reactor {
  timer t(0, 20 msec) // need this to be kind of frequent to avoid delay in 

  robot = new Robot()
  motor = new MotorsWithFeedback()
  d = new Display()

  // gets distance traveled
  encoder = new Encoders()
  c1 = new AngleToDistance()
  c2 = new AngleToDistance()

  // gets yaw measurement
  gyro = new GyroAngle()

  encoder.left -> c1.angle
  encoder.right -> c2.angle
  c1.distance -> robot.l_dist
  c2.distance -> robot.r_dist

  gyro.z -> robot.yaw

  // motor w/ feedback inputs
  robot.left -> motor.left_speed
  robot.right -> motor.right_speed
  encoder.left -> motor.left
  encoder.right -> motor.right

  robot.l0 -> d.line0
  robot.l1 -> d.line1
  robot.l2 -> d.line2
  robot.l3 -> d.line3

  reaction(t) -> encoder.trigger, gyro.trigger {=
    lf_set(encoder.trigger, true);
    lf_set(gyro.trigger, true);
  =}
}
