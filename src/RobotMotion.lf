/**
  * Robot Motion Main Robot Control
  */

target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  single-threaded: true
}

import Display from "lib/Display.lf"
// import Motors from "lib/Motors.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import GyroAngle from "lib/IMU.lf"
import Encoders from "lib/Encoders.lf"

preamble {=
  #include <math.h>
  #include "pico/stdlib.h"
=}

// returns distance travelled in meters.
reactor AngleToDistance {
  input angle: int32_t
  output distance: float

  reaction(angle) -> distance {=
      // arc length = theta * r, where theta is in radians
      lf_set(distance, (float) angle->value * ((float) M_PI / 180.0f) * (0.03175f / 2.0f));
  =}
}

reactor Robot {
  reset state temp_dist: float = 0
  input l_dist: float
  input r_dist: float

  reset state temp_angle: float = 0
  input yaw: float     // Yaw angle

  // outputs for motor
  output left: float
  output right: float

  output l0: string
  output l1: string
  output l2: string
  output l3: string

  timer t1(0, 20 ms)

  state buf: char[17] = {0}
  state idx: int = 0

  initial mode DRIVING {
    reaction(t1) -> l0, l2, l3 {=
      lf_set(l0, "receiving data");

      static char buf0[17];
      snprintf(buf0, 17, "size: %4d", sizeof(self->buf) - 1);

      lf_set(l2, buf0);

      int c;
      while ((c = getchar_timeout_us(0)) != PICO_ERROR_TIMEOUT) {
        if (c == '\n' || c == '\r') {
          self->buf[self->idx] = '\0';
          lf_set(l3, self->buf);
          self->idx = 0;
        } else if (self->idx < 17 - 1) {
          self->buf[self->idx++] = (char)c;
        }
      }

      // int c = getchar_timeout_us(0); // non-blocking read
      // if (c != PICO_ERROR_TIMEOUT) {
      //   if (c == '\n' || c == '\r') {
      //     self->buf[self->idx] = '\0';
      //     lf_set(l3, self->buf); // write to pololu screen
      //     self->idx = 0;
      //   } else if (self->idx < sizeof(self->buf) - 1) {
      //     self->buf[self->idx++] = (char)c;
      //   }
      // }
    =}

  //   reaction(l_dist, r_dist) yaw -> reset(TURNING), l0, l2, l3, left, right {=
  //     lf_set(l0, "receive data");

  //   //   lf_set(left, 0.1f);
  //   //   lf_set(right, 0.1f);

  //   //   float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;

  //   //   if (fabs(self->temp_dist - lr_avg_dist) >= 2.0f) {
  //   //     lf_set(l0, "stop");
  //   //     lf_set(left, 0.0f);
  //   //     lf_set(right, 0.0f);

  //   //     self->temp_angle = yaw->value;

  //   //     lf_set_mode(TURNING);
  //   //   }
  //   =}
  // }

  // mode TURNING {
  //   reaction(yaw) l_dist, r_dist -> reset(DRIVING), l0, left, right {=
  //     lf_set(l0, "TURNING");

  //     lf_set(left, 0.0f);
  //     lf_set(right, self->r_speed);

  //     if (fabs(self->temp_angle - yaw->value) >= 90) {
  //       lf_set(l0, "stop turning");

  //       lf_set(left, 0.0f);
  //       lf_set(right, 0.0f);

  //       float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;
  //       self->temp_dist = lr_avg_dist;
  //       self->temp_angle = yaw->value;

  //       lf_set_mode(DRIVING);

  //     }
  //   =}
  }
}
  
main reactor {
  timer t(0, 20 msec) // need this to be kind of frequent to avoid delay in 

  robot = new Robot()
  motor = new MotorsWithFeedback()
  d = new Display()

  // gets distance traveled
  encoder = new Encoders()
  c1 = new AngleToDistance()
  c2 = new AngleToDistance()

  // gets yaw measurement
  gyro = new GyroAngle()

  encoder.left -> c1.angle
  encoder.right -> c2.angle
  c1.distance -> robot.l_dist
  c2.distance -> robot.r_dist

  gyro.z -> robot.yaw

  // motor w/ feedback inputs
  robot.left -> motor.left_speed
  robot.right -> motor.right_speed
  encoder.left -> motor.left
  encoder.right -> motor.right

  robot.l0 -> d.line0
  robot.l1 -> d.line1
  robot.l2 -> d.line2
  robot.l3 -> d.line3

  reaction(t) -> encoder.trigger, gyro.trigger {=
    lf_set(encoder.trigger, true);
    lf_set(gyro.trigger, true);
  =}
}
