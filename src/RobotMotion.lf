/**
  * Robot Motion Main Robot Control
  */

target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  single-threaded: true
}

import Display from "lib/Display.lf"
import Motors from "lib/Motors.lf"
import GyroAngle from "lib/IMU.lf"
import Encoders from "lib/Encoders.lf"
// import EdgeSensor from "EdgeSensor.lf"

preamble {=
  #include <math.h>
=}

// returns distance travelled in meters.
reactor AngleToDistance {
  input angle: int32_t
  output distance: float

  reaction(angle) -> distance {=
      // arc length = theta * r, where theta is in radians
      lf_set(distance, (float) angle->value * ((float) M_PI / 180.0f) * (0.03175f / 2.0f));
  =}
}

reactor Robot {
  motor = new Motors()

  reset state temp_dist: float = 0
  input l_dist: float
  input r_dist: float

  reset state temp_angle: float = 0
  input yaw: float     // Yaw angle

  output l0: string
  output l1: string
  output l2: string
  output l3: string

  initial mode OBSERVING {
    // is the goal target in my vision?
    // if yes, change mode to pathfind
    // if no, search
  }

  mode SEARCH {
    // different naive implementations
    // 1. random walk
    // 2. spiral

    // lets assume random walk for now
    // start in scan mode, ask VLM if target is in view: if yes, switch to pathfind
    // else: turn a random angle,
    // then move forward a random angle
    // if obstacle (object that is not target) in view, back up and turn? or maybe use bump sensor?
    // after, go back to OBSERVING
  }

  mode PATHFIND {
    // target object has been found, start travelling toward it
    // keep object in center as much as possible
    // if target is behind an object, try to navigate around it
    // maybe keep some bias direction so the robot knows to eventually travel to it after avoiding

  }

    mode BACKUP {
      reaction(l_dist, r_dist) yaw -> reset(BACKUP_TURN), l3, motor.right_power, motor.left_power {=
        lf_set(l3, "backing up");

        lf_set(motor.left_power, -0.1f);
        lf_set(motor.right_power, -0.1f);

        float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;

        if (fabs(self->temp_dist - lr_avg_dist) >= 0.1f) {
          lf_set(l3, "stop");
          lf_set(motor.left_power, 0.0f);
          lf_set(motor.right_power, 0.0f);

          // get snapshot of angle turned
          self->temp_angle = yaw->value;

          lf_set_mode(BACKUP_TURN);
        }
      =}
    }

    mode BACKUP_TURN {
      reaction(yaw) l_dist, r_dist -> reset(DRIVING), l3, motor.left_power, motor.right_power {=
        lf_set(motor.left_power, -0.1f);

        if (fabs(self->temp_angle - yaw->value) >= 25) {
          lf_set(l3, "stop turning");

          lf_set(motor.left_power, 0.0f);

          float lr_avg_dist = (l_dist->value + r_dist->value) / 2.0f;
          self->temp_dist = lr_avg_dist;

          lf_set_mode(DRIVING);
        }
      =}
    }
  }
  
main reactor {
  timer t(0, 20 msec) // need this to be kind of frequent to avoid delay in 
  
  r = new Robot()
  d = new Display()

  // gets distance traveled
  encoder = new Encoders()
  c1 = new AngleToDistance()
  c2 = new AngleToDistance()

  // gets yaw measurement
  g = new GyroAngle()

  encoder.left -> c1.angle
  encoder.right -> c2.angle
  c1.distance -> r.l_dist
  c2.distance -> r.r_dist

  g.z -> r.yaw

  r.l0 -> d.line0
  r.l1 -> d.line1
  r.l2 -> d.line2
  r.l3 -> d.line3

  reaction(t) -> encoder.trigger, g.trigger {=
    lf_set(encoder.trigger, true);
    lf_set(g.trigger, true);
  =}
}
